import Graphics2D;
import Math;

class vertexrenderer{
	
	field screenwidth=100;
	field screenheight=100;
	
	function tri_inter(ax,ay,bx,by,cx,cy,px,py){ //Triangular Iterpolation
		a =((ax-bx)*(ay-py))-((ay-by)*(ax-px)); //Area of Opposite-C
		b =((cx-ax)*(cy-py))-((cy-ay)*(cx-px));  //Area of Opposite-B
		c =((bx-cx)*(by-py))-((by-cy)*(bx-px)); //Area of Opposite-A
		if((a>=0&&b>=0&&c>=0)||(a<=0&&b<=0&&c<=0)){
			d=((ax-bx)*(by-cy))-((ay-by)*(bx-cx));
			if(d==0){
				return [0,0,0];
			}
			return [a/d,b/d,c/d];
		}else{
			return null;
		}
	}
	
	
	function draw_scene(cam,coords,polys){ 
	zindex=[];
	zindex.add(0);
	screen_coords=cam.pj_screen_space(coords,this.screenwidth,this.screenheight,true);
	//Assemble an index list of the coords sorted by z-score
	confident = []; //Polygons that we are CERTAIN do not overlap with ANYTHING
	problem_children = [];
	for(index=1;index<screen_coords.length;index++){
	 beg=0;
	 end=zindex.length-1;
	 while(true){
		if(beg>end){
			zindex.insert(beg,index);
			break;
		}
		if(beg==end){
			if(screen_coords[index][2]>screen_coords[zindex[beg]][2]){
				zindex.insert(beg+1,index);
				break;
			}else{
				zindex.insert(beg,index);
				break;
			}
			break;
		}
			mid=(beg+end)/2;
			if(screen_coords[index][2]>screen_coords[zindex[mid]][2]){
				beg=mid+1;
				
			}else if(screen_coords[index][2]<screen_coords[zindex[mid]][2]){
				end=mid-1;
			}else{
				zindex.insert(mid,index);
				break;
			}
		}
	 }


	}
	
	function polish(poly,interpol){
		return [255,255,255];
	}

}